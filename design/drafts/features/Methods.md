Методы в языке Effex являются чисто синаксической конструкцией, то есть это обычные функции, но которые вызываются через точку. Однако есть одна важная особенность - методы могут быть перегруженными, в отличии от обычных функций.

## Определение методов

Синтаксис определения простого метода:
```rust
fn (a: i32) add(b: i32) -> i32 { a + b }
```

Как видно, он очень похож на тот, который используется в языке Golang. Слева от имени метода указывается аргумент, на котором будет вызван метод, а справа в скобках указываются аргументы метода.

Методы могут быть параметрически полиморфными, то есть метод может быть определен для нескольких типов аргументов.
```rust
fn <A>(a: A) add<B>(b: B) -> @Add<A, B>::Effects Add<A, B>::Result where Add<A, B> {
  a + b
}
```

В рамках модуля не могут быть объявлены методы с одинаковым именем, соответственно путь `package::module::path::method` однозначно идентифицирует метод.

## Вызов методов
Вызов методов осуществляется через точку.
```rust
let result = 1.add(2);
```

Кроме того, вызов метода может быть квалифицирован, то есть с указанием модуля или пакета.
```rust
let result = a.package::module::path::method(b);
```

## Область видимости методов и модули
Как уже было сказано, методы могут быть объявлены в модулях, но при этом в рамках модуля не могут быть объявлены методы с одинаковым именем, это нужно, чтобы существовал путь `package::module::path::method` который однозначно идентифицирует метод.

Так же методы могут реэкспортированы. Один модуль может реэкспортировать множество методов с одинаковым именем, но есть ограничения:
- модуль `m` реэкспортирующий методы с именем `x` не должен экспортировать метод с именем `x` объявленый в этом модуле
- для каждого реэкспортируемого метода с именем `x` должен существовать модуль в данном пакете, который однозначно идентифицирует метод

Помимо явно экспортируемых методов существуют методы объявленные в модулях компаньёнах для типов данных. Такие методы не нужно явно экспортировать в скоуп для использования, если в голове левого аргумента (либо под типом ссылки) находится тип, с которым ассоциирован модуль компаньён.
